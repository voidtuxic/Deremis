<?xml version="1.0" encoding="utf-8"?>
<shader version="1">
    <config>
        <BlendState>SingleAlphaBlend</BlendState>
        <DepthStencilState depthTestEnabled="true" depthWriteEnabled="true" comparisonKind="LessEqual" />
        <RasterizerState depthClipEnabled="true" scissorTestEnabled="false" cullMode="Back" fillMode="Solid" frontFace="Clockwise" />
        <PrimitiveTopology>TriangleList</PrimitiveTopology>
    </config>
    <properties>
        <vec3 name="diffuseColor" />
        <vec3 name="specularColor" />
        <float name="ambientStrength" />
        <float name="specularStrength" />
    </properties>
    <resources>
        <texture2d name="diffuseTexture" />
        <texture2d name="specularTexture" />
        <texture2d name="normalTexture" />
    </resources>
    <vertex>
#version 450

layout(set = 0, binding = 0) uniform Transform
{
    mat4 ViewProj;
    mat4 World;
    mat4 NormalWorld;
};

layout(location = 0) in vec3 Position;
layout(location = 1) in vec3 Normal;
layout(location = 2) in vec2 UV;
layout(location = 3) in vec3 Tangent;
layout(location = 4) in vec3 Bitangent;

layout(location = 0) out vec3 f_position;
layout(location = 1) out vec2 f_UV;
layout(location = 2) out mat3 f_TBN;

void main()
{
    vec4 worldPos = World * vec4(Position, 1);
    gl_Position = ViewProj * worldPos;
    f_position = worldPos.xyz;
    //f_normal = mat3(NormalWorld) * Normal;
    f_UV = UV;

    vec3 T = normalize(mat3(NormalWorld) * Tangent);
    vec3 B = normalize(mat3(NormalWorld) * Bitangent);
    vec3 N = normalize(mat3(NormalWorld) * Normal);
    f_TBN = mat3(T, B, N);
}
    </vertex>
    <fragment>
#version 450

// based off http://wiki.ogre3d.org/Light+Attenuation+Shortcut
#define GAMMA 2.2
#define MAX_LIGHTS 4
#define CONSTANT 1.0
#define LINEAR_FACTOR 4.5
#define QUADRATIC_FACTOR 75.0
#define MIN_RANGE 0.001

struct LightStruct
{
    vec3 Position;
    vec3 Direction;
    vec3 Color;

    float Type;

    float Range;
    float InnerCutoff;
    float OuterCutoff;
};

layout(set = 0, binding = 0) uniform Transform
{
    mat4 ViewProj;
    mat4 World;
    mat4 NormalWorld;
};
layout(set = 0, binding = 1) uniform Material
{
    vec3 diffuseColor;
    vec3 specularColor;
    float ambientStrength;
    float specularStrength;
};
layout(set = 0, binding = 2) uniform Light {
    LightStruct Lights[MAX_LIGHTS];
};

layout(set = 1, binding = 0) uniform texture2D diffuseTexture;
layout(set = 1, binding = 1) uniform texture2D specularTexture;
layout(set = 1, binding = 2) uniform texture2D normalTexture;
layout(set = 1, binding = 3) uniform sampler texSampler;

layout(location = 0) in vec3 f_position;
layout(location = 1) in vec2 f_UV;
layout(location = 2) in mat3 f_TBN;

layout(location = 0) out vec4 out_Color;

vec3 CorrectGamma(vec3 color) {
    return pow(color, vec3(GAMMA));
}

vec3 CalculateLight(vec3 lightDir, vec3 lightColor, float attenuation, float intensity) 
{    
    // edgy
    vec3 viewPos = vec3(ViewProj[0][3], ViewProj[1][3], ViewProj[2][3]);
    vec3 viewDir = normalize(viewPos - f_position);
    vec3 halfwayDir = normalize(lightDir + viewDir);

    vec3 diffTex = texture(sampler2D(diffuseTexture, texSampler), f_UV).rgb;
    vec3 specTex = texture(sampler2D(specularTexture, texSampler), f_UV).rgb;
    vec3 norm = texture(sampler2D(normalTexture, texSampler), f_UV).rgb;

    diffTex = CorrectGamma(diffTex);
    norm = norm * 2.0 - 1.0;
    norm = normalize(f_TBN * norm); 

    vec3 ambient = ambientStrength * lightColor;

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = (diff * diffuseColor * diffTex) * lightColor;

    float spec = pow(max(dot(norm, halfwayDir), 0.0), 32);
    vec3 specular = (specularStrength * spec * specularColor * specTex) * lightColor;

    ambient  *= attenuation; 
    diffuse  *= attenuation;
    specular *= attenuation;

    diffuse  *= intensity;
    specular *= intensity;

    return ambient + diffuse + specular;
}

void main()
{
    vec3 color;
    
    for(int i = 0; i &lt; MAX_LIGHTS; i++)
    {
        float lightType = Lights[i].Type;
        vec3 lightPosition = Lights[i].Position;
        vec3 lightDirection = Lights[i].Direction;
        vec3 lightColor = Lights[i].Color;
        if(lightType == 0)
        {
            vec3 lightDir = normalize(-lightDirection);
            color += CalculateLight(lightDir, lightColor, CONSTANT, 1.0);
        }
        else if (lightType == 1)
        {
            float lightRange = Lights[i].Range;
            vec3 lightDir = normalize(lightPosition - f_position);
            float range = max(MIN_RANGE, lightRange);
            float linear = LINEAR_FACTOR/range;
            float quadratic = QUADRATIC_FACTOR/(range*range);
            float distance = length(lightPosition - f_position);
            color += CalculateLight(lightDir, lightColor, 1.0 / (CONSTANT + linear * distance + quadratic * (distance * distance)), 1.0);
        }
        else if (lightType == 2)
        {
            float lightInnerCutOff = Lights[i].InnerCutoff;
            float lightOuterCutOff = Lights[i].OuterCutoff;
            vec3 lightDir = normalize(lightPosition - f_position);
            float theta = dot(lightDir, normalize(-lightDirection));
            float epsilon = lightInnerCutOff - lightOuterCutOff;
            float intensity = clamp((theta - lightOuterCutOff) / epsilon, 0.0, 1.0); 
            color += CalculateLight(lightDir, lightColor, CONSTANT, intensity);
        }
    }

    out_Color = vec4(color, 1);
}
    </fragment>
</shader>