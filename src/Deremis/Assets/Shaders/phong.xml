<?xml version="1.0" encoding="utf-8"?>
<shader version="1">
    <config>
        <BlendState>SingleAlphaBlend</BlendState>
        <DepthStencilState depthTestEnabled="true" depthWriteEnabled="true" comparisonKind="LessEqual" />
        <RasterizerState depthClipEnabled="true" scissorTestEnabled="false" cullMode="Back" fillMode="Solid" frontFace="Clockwise" />
        <PrimitiveTopology>TriangleList</PrimitiveTopology>
    </config>
    <properties>
        <vec3 name="diffuseColor" />
        <vec3 name="specularColor" />
        <float name="ambientStrength" />
        <float name="specularStrength" />
    </properties>
    <resources>
        <texture2d name="diffuseTexture" />
        <texture2d name="specularTexture" />
        <texture2d name="normalTexture" />
    </resources>
    <vertex>
#include "genericvert.glsl"
    </vertex>
    <fragment>
#version 450

#include "lighting.glsl"

layout(set = 0, binding = 0) uniform Transform
{
    mat4 ViewProj;
    mat4 World;
    mat4 NormalWorld;
};
layout(set = 0, binding = 1) uniform Material
{
    vec3 diffuseColor;
    vec3 specularColor;
    float ambientStrength;
    float specularStrength;
};
layout(set = 0, binding = 2) uniform Light {
    LightStruct Lights[MAX_LIGHTS];
};

layout(set = 1, binding = 0) uniform texture2D diffuseTexture;
layout(set = 1, binding = 1) uniform texture2D specularTexture;
layout(set = 1, binding = 2) uniform texture2D normalTexture;
layout(set = 1, binding = 3) uniform sampler texSampler;

layout(location = 0) in vec3 f_position;
layout(location = 1) in vec2 f_UV;
layout(location = 2) in mat3 f_TBN;

layout(location = 0) out vec4 out_Color;

vec3 CalculateLight(vec3 lightDir, vec3 lightColor, float attenuation, float intensity) 
{    
    // edgy
    vec3 viewPos = vec3(ViewProj[0][3], ViewProj[1][3], ViewProj[2][3]);
    vec3 viewDir = normalize(viewPos - f_position);
    vec3 halfwayDir = normalize(lightDir + viewDir);

    vec3 diffTex = texture(sampler2D(diffuseTexture, texSampler), f_UV).rgb;
    vec3 specTex = texture(sampler2D(specularTexture, texSampler), f_UV).rgb;
    vec3 norm = texture(sampler2D(normalTexture, texSampler), f_UV).rgb;

    diffTex = CorrectGamma(diffTex);
    norm = norm * 2.0 - 1.0;
    norm = normalize(f_TBN * norm); 

    vec3 ambient = ambientStrength * lightColor;

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = (diff * diffuseColor * diffTex) * lightColor;

    float spec = pow(max(dot(norm, halfwayDir), 0.0), 32);
    vec3 specular = (specularStrength * spec * specularColor * specTex) * lightColor;

    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;

    diffuse  *= intensity;
    specular *= intensity;

    return ambient + diffuse + specular;
}

void main()
{
    vec3 color;
    
    for(int i = 0; i &lt; MAX_LIGHTS; i++)
    {
        float lightType = Lights[i].Type;
        vec3 lightPosition = Lights[i].Position;
        vec3 lightDirection = Lights[i].Direction;
        vec3 lightColor = Lights[i].Color;
        if (lightType == 0)
        {
            vec3 lightDir = normalize(-lightDirection);
            color += CalculateLight(lightDir, lightColor, CONSTANT, 1.0);
        }
        else if (lightType == 1)
        {
            float lightRange = Lights[i].Range;
            vec3 lightDir = normalize(lightPosition - f_position);
            float range = max(MIN_RANGE, lightRange);
            float linear = LINEAR_FACTOR/range;
            float quadratic = QUADRATIC_FACTOR/(range*range);
            float distance = length(lightPosition - f_position);
            color += CalculateLight(lightDir, lightColor, 1.0 / (CONSTANT + linear * distance + quadratic * (distance * distance)), 1.0);
        }
        else if (lightType == 2)
        {
            float lightInnerCutOff = Lights[i].InnerCutoff;
            float lightOuterCutOff = Lights[i].OuterCutoff;
            vec3 lightDir = normalize(lightPosition - f_position);
            float theta = dot(lightDir, normalize(-lightDirection));
            float epsilon = lightInnerCutOff - lightOuterCutOff;
            float intensity = clamp((theta - lightOuterCutOff) / epsilon, 0.0, 1.0);
            color += CalculateLight(lightDir, lightColor, CONSTANT, intensity);
        }
    }

    out_Color = vec4(color, 1);
}
    </fragment>
</shader>